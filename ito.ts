// TypeScript bindings automatically generated by near-syn v0.5.1 https://github.com/acuarica/near-syn, DO NOT MODIFY!

// Exports common NEAR Rust SDK types based on https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/.

/**
 * Represents an 64 bits unsigned integer encoded as a `string`.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/struct.U64.html.
 */
export type U64 = string;

/**
 * Represents an 64 bits signed integer encoded as a `string`.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/struct.I64.html.
 */
export type I64 = string;

/**
 * Represents an 128 bits unsigned integer encoded as a `string`.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/struct.U128.html.
 */
export type U128 = string;

/**
 * Represents an 128 bits signed integer encoded as a `string`.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/struct.I128.html.
 */
export type I128 = string;

/**
 * Represents an encoded array of bytes into a `string`.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/struct.Base64VecU8.html.
 */
export type Base64VecU8 = string;

/**
 * Balance is a type for storing amounts of tokens, specified in yoctoNEAR.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/type.Balance.html.
 */
export type Balance = U128;

/**
 * Account identifier. This is the human readable UTF8 string which is used internally to index accounts on the network and their respective state.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/struct.AccountId.html.
 */
export type AccountId = string;

/**
 * DEPRECATED since 4.0.0.
 * See https://docs.rs/near-sdk/4.0.0-pre.4/near_sdk/json_types/type.ValidAccountId.html.
 */
export type ValidAccountId = string;

/**
 * Provides admin operations to change different configurations of
 * the contract.
 * 
 * The contract `owner` is the only account allowed to perform these operations.
 * Otherwise, these operations panic.
 */
export interface AdminBridge {
    /**
     * Changes Campground percentage `fee`.
     * When a creator creates a trail series,
     * the series takes this `fee` as a default `fee`.
     */
    change_campground_fee(args: { fee: number }, gas?: any): Promise<void>;

    /**
     * Changes treasury address to a new one.
     * The treasury address receives the applied `fee` after an NFT
     * has been bought.
     */
    change_campground_treasury_address(args: { addr: AccountId }, gas?: any): Promise<void>;

    /**
     * Changes campground minimum `fee`, in yoctoNEAR.
     */
    change_campground_minimum_fee(args: { fee: Balance }, gas?: any): Promise<void>;

    /**
     * Adds a setting key-val to the map
     */
    add_setting(args: { key: string, value: string }, gas?: any): Promise<void>;

}

/**
 * Approval Management
 * NEP-178 interface definition.
 * 
 * For more info,
 * see https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement.
 * 
 * Trait used when it is desired to have a non-fungible token that has a traditional escrow or approval system.
 * This allows Alice to allow Bob to take only the token with the unique identifier "19" but not others.
 * 
 * It should be noted that in the [core non-fungible token standard] there
 * is a method to do _transfer and call_ which may be preferred over using
 * an [approval management standard] in certain use cases.
 * 
 * [approval management standard]: https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html
 * [core non-fungible token standard]: https://nomicon.io/Standards/NonFungibleToken/Core.html
 */
export interface NonFungibleTokenApproval {
    /**
     * Approve an account ID to transfer a token on your behalf.
     */
    nft_approve(args: { token_id: TrailId, account_id: AccountId, msg: string|null }, gas?: any, amount?: any): Promise<void>;

    /**
     * Check if the passed in account has access to approve the token ID
     */
    nft_is_approved(args: { token_id: TrailId, approved_account_id: AccountId, approval_id: number|null }): Promise<void>;

    /**
     * Revoke a specific account from transferring the token on your behalf.
     */
    nft_revoke(args: { token_id: TrailId, account_id: AccountId }, gas?: any, amount?: any): Promise<void>;

    /**
     * Revoke all accounts from transferring the token on your behalf.
     */
    nft_revoke_all(args: { token_id: TrailId }, gas?: any, amount?: any): Promise<void>;

}

/**
 */
export interface SeriesBridge {
    /**
     * Returns whether a trail is available in the smart contract.
     */
    series_exists(args: { series_id: TrailId }): Promise<boolean>;

    /**
     * Returns the owner of the smart contract
     */
    get_owner(): Promise<AccountId>;

    /**
     * Returns a trail by trail ID if any, `null` otherwise.
     */
    get_trail_by_id_optional(args: { series_id: TrailId }): Promise<TrailSeries|null>;

    /**
     * Returns a trail if found or panics if not.
     */
    get_trail_by_id(args: { series_id: TrailId }): Promise<TrailSeries>;

    /**
     * Verifies whether a given user, `AccountId` owns the copy of a trail.
     */
    is_owner(args: { series_id: TrailIdAndCopyNumber, owner_id: AccountId }): Promise<boolean>;

    /**
     * Verifies whether a given user, `AccountId` is the creator of a given trail.
     */
    is_creator(args: { series_id: TrailId, owner_id: AccountId }): Promise<boolean>;

    /**
     * Returns the business information of a trail, `null` otherwise.
     */
    get_trail_business(args: { trail_and_copy_id: TrailIdAndCopyNumber }): Promise<TrailBusiness|null>;

    /**
     * Returns all the trail copies owned by a given user, `AccountId`.
     */
    get_all_trails_by_owner(args: { owner_id: AccountId }): Promise<TrailSeries[]>;

    /**
     * Returns all the trails created by a given user (AccountId).
     */
    get_all_trails_by_creator(args: { creator_id: AccountId }): Promise<TrailSeries[]>;

    /**
     * Returns the current minimum fee in YoctoNEAR by campground.
     */
    get_current_fee(): Promise<U128>;

    /**
     * Returns the percentage amount Campground takes from each buy order if higher than minimum fee.
     */
    get_fee_percentage(): Promise<number>;

    /**
     * Returns the address where treasury funds are transferred to.
     */
    get_treasury_address(): Promise<AccountId>;

    /**
     * Whether caller is the owner of the contract.
     */
    is_caller_contract_owner(): Promise<boolean>;

    /**
     * Whether a trail can be minted by the user or not (for fiat/near purposes)
     */
    is_trail_mintable(args: { trail_id: TrailId }): Promise<boolean>;

    /**
     * Verifies there is a whitelisted address
     */
    is_there_whitelisted_address(): Promise<boolean>;

    /**
     * Gets the address of a whitelisted address
     */
    get_whitelisted_address(): Promise<AccountId>;

}

/**
 * Provides operations to deal with trail series.
 */
export interface CreateTrailSeries {
    /**
     */
    create_trail_series_estimated(args: { metadata: TrailSeriesMetadata, price: U128|null, creator_id: AccountId|null, creator_royalty: U128|null, allow_user_minting: boolean|null }): Promise<U128|null>;

    /**
     * Creates a series (trail) inside the smart contract.
     */
    create_trail_series(args: { metadata: TrailSeriesMetadata, price: U128|null, creator_id: AccountId|null, creator_royalty: U128|null, allow_user_minting: boolean|null }, gas?: any, amount?: any): Promise<JsonTrail>;

}

/**
 * NEP-181 interface definition.
 * 
 * See https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration.
 */
export interface NonFungibleTokenEnumeration {
    /**
     * Query for the total supply of NFTs on the contract.
     */
    nft_total_supply(): Promise<U128>;

    /**
     * Query for nft tokens on the contract regardless of the owner using pagination.
     * Query for nft tokens on the contract regardless of the owner using pagination.
     */
    nft_tokens(args: { from_index: U128|null, limit: number|null }): Promise<JsonTrail[]>;

    /**
     * Get the total supply of NFTs for a given owner.
     * Get the total supply of NFTs for a given owner.
     */
    nft_supply_for_owner(args: { account_id: AccountId }): Promise<U128>;

    /**
     * Query all tokens of an owner.
     * Similar to get_all_trails_by_owner with pagination.
     * Query all tokens of an owner.
     * Similar to get_all_trails_by_owner with pagination.
     */
    trail_tickets_for_owner(args: { account_id: AccountId, from_index: U128|null, limit: number|null }): Promise<JsonTrail[]>;

    /**
     * Get list of all tokens owned by a given account
     * Get list of all tokens owned by a given account
     */
    nft_tokens_for_owner(args: { account_id: AccountId, from_index: U128|null, limit: number|null }): Promise<JsonTrail[]>;

}

/**
 */
export enum NearEvent {
    /**
     */
    Nep171,

}

/**
 */
export type Nep171Event = {
    /**
     */
    version: string;

    /**
     */
    event_kind: Nep171EventKind;

}

/**
 */
export enum Nep171EventKind {
    /**
     */
    NftMint,

    /**
     */
    NftTransfer,

}

/**
 */
export type NftMintData = {
    /**
     */
    owner_id: string;

    /**
     */
    token_ids: string[];

    /**
     */
    memo: string|null;

}

/**
 */
export type NftTransferData = {
    /**
     */
    authorized_id: string|null;

    /**
     */
    old_owner_id: string;

    /**
     */
    new_owner_id: string;

    /**
     */
    token_ids: string[];

    /**
     */
    memo: string|null;

}

/**
 */
export interface Contract {
    /**
     * Initialization function (can only be called once).
     * This initializes the contract with default metadata so the
     * user doesn't have to manually type metadata.
     */
    new_default_meta: { owner_id: AccountId, treasury_id: AccountId };

    /**
     * Initialization function (can only be called once).
     * This initializes the contract with metadata that was passed in and
     * the `owner_id`.
     */
    new: { owner_id: AccountId, metadata: NFTContractMetadata, treasury_id: AccountId };

}

/**
 */
export interface Contract {
    /**
     * Returns the price of the given `trail_series_id`.
     * The price is the final amount to be payed to buy the nft.
     */
    nft_get_series_price(args: { trail_series_id: TrailId }): Promise<U128>;

    /**
     * Buys a trail series if still available given a price and attached deposit.
     */
    nft_buy_series(args: { trail_series_id: TrailId, receiver_id: AccountId }, gas?: any, amount?: any): Promise<TrailIdAndCopyNumber>;

    /**
     */
    nft_mint(args: { token_id: TrailId, receiver_id: AccountId }, gas?: any, amount?: any): Promise<TrailIdAndCopyNumber>;

}

/**
 */
export type TrailId = string;

/**
 */
export type TrailIdAndCopyNumber = string;

/**
 */
export type Payout = {
    /**
     */
    payout: Record<AccountId, U128>;

}

/**
 */
export type NFTContractMetadata = {
    /**
     * Required, essentially a version like "nft-1.0.0"
     */
    spec: string;

    /**
     * required, ex. "Mosaics"
     */
    name: string;

    /**
     * required, ex. "MOSIAC"
     */
    symbol: string;

    /**
     * Data URL
     */
    icon: string|null;

    /**
     * Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
     */
    base_uri: string|null;

    /**
     * URL to a JSON file with more info
     */
    reference: string|null;

    /**
     * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
     */
    reference_hash: Base64VecU8|null;

}

/**
 */
export type TrailResource = {
    /**
     * ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
     */
    title: string|null;

    /**
     * free-form description
     */
    description: string|null;

    /**
     * URL to associated media, preferably to decentralized, content-addressed storage
     */
    media: string;

    /**
     * anything extra the NFT wants to store on-chain. Can be stringified JSON.
     */
    extra: string|null;

    /**
     * Url referencing something of this resource
     */
    reference: string|null;

}

/**
 */
export type SeriesSupply = {
    /**
     */
    total: number;

    /**
     */
    circulating: number;

}

/**
 */
export type TrailSeriesMetadata = {
    /**
     */
    title: string;

    /**
     */
    description: string;

    /**
     */
    tickets_amount: number;

    /**
     */
    media: string|null;

    /**
     */
    data: string|null;

    /**
     */
    resources: TrailResource[];

    /**
     * When token starts being valid, Unix epoch in milliseconds
     */
    starts_at: number|null;

    /**
     * When token expires, Unix epoch in milliseconds,
     */
    expires_at: number|null;

    /**
     * Url referencing something of this resource,
     */
    reference: string|null;

    /**
     */
    campground_id: string;

}

/**
 * As defined in NEP-177.
 */
export type TokenMetadata = {
    /**
     * ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
     */
    title: string|null;

    /**
     * free-form description
     */
    description: string|null;

    /**
     * URL to associated media, preferably to decentralized, content-addressed storage
     */
    media: string|null;

    /**
     * Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
     */
    media_hash: Base64VecU8|null;

    /**
     * number of copies of this set of metadata in existence when token was minted.
     */
    copies: number|null;

    /**
     * When token was issued or minted, Unix epoch in milliseconds
     */
    issued_at: number|null;

    /**
     * When token expires, Unix epoch in milliseconds
     */
    expires_at: number|null;

    /**
     * When token starts being valid, Unix epoch in milliseconds
     */
    starts_at: number|null;

    /**
     * When token was last updated, Unix epoch in milliseconds
     */
    updated_at: number|null;

    /**
     * anything extra the NFT wants to store on-chain. Can be stringified JSON.
     */
    extra: string|null;

    /**
     * URL to an off-chain JSON file with more info.
     */
    reference: string|null;

    /**
     * Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
     */
    reference_hash: Base64VecU8|null;

}

/**
 */
export type TrailSeries = {
    /**
     */
    is_mintable: boolean;

    /**
     */
    creator_id: AccountId;

    /**
     */
    issue_at: number;

    /**
     */
    metadata: TrailSeriesMetadata;

    /**
     */
    supply: SeriesSupply;

    /**
     */
    price: U128;

    /**
     */
    campground_fee_near: U128;

    /**
     */
    creator_royalty_near: U128|null;

    /**
     */
    royalties: Record<AccountId, number>;

}

/**
 */
export type TrailBusiness = {
    /**
     * Owner of the token
     */
    owner_id: AccountId;

    /**
     */
    token_id: TrailId;

    /**
     */
    partial_metadata: TokenMetadata;

}

/**
 * The Json token is what will be returned from view calls.
 */
export type JsonTrail = {
    /**
     * token ID
     */
    token_id: TrailId;

    /**
     * owner of the token
     */
    owner_id: AccountId;

    /**
     * token metadata
     */
    series: TrailSeries;

    /**
     * NEAR metadata
     */
    metadata: TokenMetadata;

}

/**
 * NEP-177 interface definition.
 * 
 * See https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata.
 */
export interface NonFungibleTokenMetadata {
    /**
     * View call for returning the contract metadata
     */
    nft_metadata(): Promise<NFTContractMetadata>;

}

/**
 */
export interface NonFungibleTokenCore {
    /**
     */
    nft_transfer(args: { receiver_id: AccountId, token_id: TrailIdAndCopyNumber, memo: string|null }, gas?: any, amount?: any): Promise<void>;

    /**
     * Returns `true` if the token was transferred from the sender's account.
     */
    nft_transfer_call(args: { receiver_id: AccountId, token_id: TrailId, memo: string|null, msg: string }, gas?: any, amount?: any): Promise<void>;

    /**
     */
    nft_token(args: { token_id: TrailIdAndCopyNumber }): Promise<JsonTrail|null>;

}

/**
 */
export interface NonFungibleTokenPayouts {
    /**
     */
    nft_payout(args: { token_id: TrailId, balance: U128, max_len_payout: number }): Promise<void>;

    /**
     */
    nft_transfer_payout(args: { receiver_id: AccountId, token_id: TrailId, approval_id: number, memo: string, balance: U128, max_len_payout: number }, gas?: any, amount?: any): Promise<void>;

}

/**
 * This trait complies with functions that can only be accessed by settings.SUB_ADMIN_ADDRESS
 */
export interface SubAdminBridge {
    /**
     * Remove a trail from nonmintable_trails so that it can be minted by users again
     */
    remove_trail_from_nonmintable_list(args: { trail_id: TrailId }, gas?: any): Promise<boolean>;

    /**
     * Includes a trail in the list of non-user mintable
     */
    insert_trail_from_nonmintable_list(args: { trail_id: TrailId }, gas?: any): Promise<boolean>;

    /**
     * Verifies whether caller is subadmin
     */
    is_caller_subadmin(): Promise<boolean>;

    /**
     * Gets accountId of sub admin
     */
    get_subadmin(): Promise<AccountId>;

}

export interface Contract extends AdminBridge, NonFungibleTokenApproval, SeriesBridge, CreateTrailSeries, NonFungibleTokenEnumeration, NonFungibleTokenMetadata, NonFungibleTokenCore, NonFungibleTokenPayouts, SubAdminBridge {}

export const ContractMethods = {
    viewMethods: [
        "nft_is_approved",
        "series_exists",
        "get_owner",
        "get_trail_by_id_optional",
        "get_trail_by_id",
        "is_owner",
        "is_creator",
        "get_trail_business",
        "get_all_trails_by_owner",
        "get_all_trails_by_creator",
        "get_current_fee",
        "get_fee_percentage",
        "get_treasury_address",
        "is_caller_contract_owner",
        "is_trail_mintable",
        "is_there_whitelisted_address",
        "get_whitelisted_address",
        "create_trail_series_estimated",
        "nft_total_supply",
        "nft_tokens",
        "nft_supply_for_owner",
        "trail_tickets_for_owner",
        "nft_tokens_for_owner",
        "nft_get_series_price",
        "nft_metadata",
        "nft_token",
        "nft_payout",
        "is_caller_subadmin",
        "get_subadmin",
    ],
    changeMethods: [
        "change_campground_fee",
        "change_campground_treasury_address",
        "change_campground_minimum_fee",
        "add_setting",
        "nft_approve",
        "nft_revoke",
        "nft_revoke_all",
        "create_trail_series",
        "nft_buy_series",
        "nft_mint",
        "nft_transfer",
        "nft_transfer_call",
        "nft_transfer_payout",
        "remove_trail_from_nonmintable_list",
        "insert_trail_from_nonmintable_list",
    ],
};
